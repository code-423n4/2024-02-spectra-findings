# Spectra Report

## Summary

**What is Spectra Protocol?**

Spectra is a protocol that uses interest derivatives to help grow the funds of their investors. With Spectra, users can efficiently divide the yield generated by an Interest Bearing Token (IBT) from the principal asset. Before we go further let's define what an Interest Bearing Token is for deeper understanding.

An Interest Bearing Token (IBT) represents ownership in an asset while also accruing interest over time. Examples of IBTs include cTokens (e.g., cETH representing ETH deposited in Compound Protocol) and aTokens (e.g., aUSDC representing USDC deposited in Aave Protocol).

When a user deposits an IBT or underlying asset into the protocol, they receive both Principal Tokens (PT) and Yield Tokens (YT) in return. The PT represents the principal asset, while the YT represents the yield generated by the IBT. Holders of YT for a specific IBT have the opportunity to claim the yield generated by the corresponding deposited IBTs as long as they hold the YT.

**What is the Purpose of the protocol?**

The protocol allows users to deposit Interest Bearing Tokens (IBT) or underlying assets to earn interest over time. Additionally, it offers flash loans for users who want to borrow IBTs. This dual functionality provides flexibility and liquidity, enhancing the protocol's utility and fostering ecosystem growth by facilitating various financial activities.

### **Approach**

1. I thoroughly reviewed the documentation (https://dev.spectra.finance/) to gain a comprehensive understanding of the protocol's functionalities and features.
2. I engaged with a similar protocol, Pendle Finance, to further deepen my understanding of interest rate derivatives protocols and their operational mechanics.
3. I delved into the overview and additional resources provided in the GitHub ReadMe to gather insights into the protocol's design principles, objectives, and implementation details.
4. Studying the codebase extensively, I meticulously analyzed the smart contracts to gain insights into the underlying architecture, logic flow, and key components. During this process, I documented relevant comments and observations to enhance my comprehension.
5. I meticulously examined the test suite, ensuring to execute all tests to validate the functionality and robustness of the protocol. I paid particular attention to user interaction patterns and fee calculation mechanisms, aiming to gain a holistic understanding of how users interact with the protocol and how fees are accrued.

### Codebase Analysis

The codebase demonstrates exceptional quality, reflecting the team's expertise and dedication. The extensive test coverage ensures thorough validation of all functions and scenarios, facilitating easy comprehension and bolstering confidence in the protocol's reliability. I commend the team for their exemplary work, and I'm committed to upholding the same standards in my contributions.

The codebase under the scope is divided into 7 contracts.

1. **PrincipalToken.sol ([src/tokens/PrincipalToken.sol](https://github.com/code-423n4/2024-02-spectra/blob/main/src/tokens/PrincipalToken.sol)):** The Principal Token serves as the primary contract within Spectra. Users exchange their IBT for Principal Tokens and Yield Tokens upon depositing their assets.
    
    **deposit(uint256 assets, address receiver):** This function is where a user can deposit assets. It returns the shares given to the user for depositing an underlying asset.
    
    **deposit(uint256 assets, address ptReceiver,  address ytReceiver):** This function deposit assets of the user to the protocol. Here the asset is transferred to the contract and the allowance of the ibt via the asset is increased, the assets is also deposited to the ibts and shares are returned. The last function _depositIBT is expected to mints and burn the PT and YT tokens. It returns the shares given to the user for depositing an underlying asset.
    
    **deposit(uint256 assets, address ptReceiver, address ytReceiver, uint256 minShares):**  This function deposits to the protocol and also checks if the returned shares value is greater than the min Shares.
    
    **depositIBT(uint256 ibts, address receiver):** This function deposits IBT to the protocol and mint YT and PT to the user. It returns the shares given to the user for depositing IBT.
    
    **depositIBT(uint256 ibts, address ptReceiver,  address ytReceiver):** This function deposit ibts of the user to the protocol. It returns the shares given to the user for depositing IBT.
    
    **depositIBT(uint256 ibts, address ptReceiver, address ytReceiver, uint256 minShares):**  This function deposits to the protocol and also checks if the returned shares value is greater than the min Shares.
    
    **redeem(uint256 shares,address receiver,address owner):** This function is use to redeem the amount of assets a user have. It returns the assets.
    
    **redeem(uint256 shares,address receiver,address owner,uint256 minAssets):** This function redeems but one addition thing it does is to check if the minAssets less than the amount.
    
    **redeemIBT(uint256 shares,address receiver,address owner):** This function is use to redeem the amount of ibts a user have. It returns the amount of ibts.
    
    **redeemIBT(uint256 shares,address receiver,address owner,uint256 minAssets):** This function redeems but one addition thing it does is to check if the minIbts are less than the amount.
    
    **withdraw(uint256 assets, address receiver, address owner):** This function helps a user to withdraw a asset.
    
    **withdrawIBT(uint256 ibts, address receiver, address owner):** This function helps a user to withdraw a asset.
    
    **withdrawIBT(uint256 ibts, address receiver, address owner, uint256 maxShares):** This function helps a user to withdraw a IBT, and then check if the shares are greater than the maxShares.
    
    **claimFees():** This function helps to claim Fee of and redeem the ibts of a user.
    
    **updateYield(address _user):** This function helps to update the yield of a user.
    
    **claimYield(address _receiver):** This function helps to claim the yield of a user.
    
    **claimYieldInIBT(address _receiver):** This function helps to claim the yield of a user
    
    **beforeYtTransfer(address _from, address _to):** This function updates the yield of both sender and receiver of YTs.
    
    **claimRewards(bytes memory _data):** This function runs a claim reward.
    
    **storeRatesAtExpiry():** Gets and saves the ptRate and ibtRate.
    
    **setRewardsProxy(address _rewardsProxy):** This function sets the reward proxy.
    
    **previewDeposit(uint256 assets):** This function helps to get the amount of shares to be minted of intended deposits for an asset.
    
    **previewDepositIBT(uint256 ibts):** This function helps to get the amount of shares to be minted for the intended deposit of IBT.
    
    **maxWithdraw(address owner):** This returns the max amount of withdrawals an owner can withdraw on their underlying token.
    
    **maxDeposit(address):** This is the max deposit of an underlying asset deposited in the protocol.
    
    **previewWithdraw(uint256 assets):** This returns the amount of shares that need to be burnt for an asset to withdraw.
    
    **previewWithdrawIBT(uint256 ibts):** This function returns the amount of shares that is needed for IBT to be withdrawn.
    
    **maxWithdrawIBT(address owner):** Return the same max IBT tokens that can be withdrawn from the protocol by a user.
    
    **previewRedeem(uint256 shares):** Returns the amount of assets received for the theoretical amount of burnt shares.
    
    **previewRedeemForIBT(uint256 shares):** Returns the amount of ibt received for the theoretical amount of burnt shares.
    
    **getCurrentYieldOfUserInIBT(address _user):**  Get the current yield of a user.
    
    **maxFlashLoan(address _token):** returns the ibt balance of the contract.
    
    **flashFee(address _token, uint256 _amount):** returns the fee of flashloan.
    
    **getTokenizationFee():** This gets the tokenization Fee of Token.
    
    **flashLoan(IERC3156FlashBorrower _receiver,address _token,uint256 _amount,bytes calldata _data):** This function carry out the Flashloan operation.
    
    **_convertSharesToIBTs():** This function converts the shares of a PT to an IBT with the current rate
    
    1. **YieldToken.sol ([src/tokens/YieldToken.sol](https://github.com/code-423n4/2024-02-spectra/blob/main/src/tokens/YieldToken.sol)):** This contract enables holders of the Yield Token linked to a specific IBT to claim the yield generated by the corresponding deposited IBTs.
    2. **PrincipalTokenUtil.sol ([src/libraries/PrincipalTokenUtil.sol](https://github.com/code-423n4/2024-02-spectra/blob/main/src/libraries/PrincipalTokenUtil.sol)):** This is a utility library designed for the Principal Token contract.
    3. **RayMath.sol** ([src/libraries/RayMath.sol](https://github.com/code-423n4/2024-02-spectra/blob/main/src/libraries/RayMath.sol)): This contract is a library that converts numbers with decimals between 6 and 18 to 27 decimals (ray), providing consistency across calculations.
    4. **AMBeacon.sol** ([src/proxy/AMBeacon.sol](https://github.com/code-423n4/2024-02-spectra/blob/main/src/proxy/AMBeacon.sol)): This contract utilizes the OpenZeppelin Access Manager instead of Ownable.
    5. **AMProxyAdmin.sol** ([src/proxy/AMProxyAdmin.sol](https://github.com/code-423n4/2024-02-spectra/blob/main/src/proxy/AMProxyAdmin.sol)): The contract is derived from the OpenZeppelin ProxyAdmin, this version employs the OpenZeppelin Access Manager in place of Ownable.
    6. **AMTransparentUpgradeableProxy** ([src/proxy/AMTransparentUpgradeableProxy.sol](https://github.com/code-423n4/2024-02-spectra/blob/main/src/proxy/AMTransparentUpgradeableProxy.sol)): The contract is derived from the OpenZeppelin TransparentUpgradeableProxy, this version employs the OpenZeppelin Access Manager in place of Ownable.
    
    ---
    

### Mechanism Review

Spectra Protocol is an interest derivatives based protocol. Here is the user flow of the contract. 

A user has sDAI has an IBT token, the user has two options after having sDai either deposit to get YT and PT or buy YT and PT from the Liquidity Pool. The user will trigger the depositIBT(uint256 ibts, address receiver) where the amount of sDai is deposited and Principal token and Yield token is issued to the user. Note if a user deposits, 1000 sDai the user will receive 1000 YT and PT. The value of YT, it is estimated by the IBT protocol and can be changed based on market price if a user have 1000 PT and YT base on the initial deposit he can choose to buy more YT for future profit or sell of immediately and get profit base on the current rate through the claimYield(address _receiver).

The codebase is cool and one thing I notice is that it was written that  the PrincipalToken (PT) is an ERC5095 vault in the @notice of the PrincipalToken contract but I find out that the PrincipalToken used mainly ERC4626 vault. 

Another issue I notice, though it has been said in the bot report is the issue of zero address on some key areas. I think it necessary to always check the address inputted by the user or any personnel interacting with the protocol. 

### Systemic risks

There was a good implementation of the external contracts, the only issue I notice is the discrepancy in the @notice of the PrincipalToken contract regarding the vault type. While it states ERC5095, the actual implementation primarily utilizes ERC4626 vaults. Clarifying this inconsistency will enhance user understanding.

 It's essential to implement robust checks for zero address inputs to mitigate potential risks associated with user interactions. Ensuring all addresses are properly validated will bolster the protocol's security and reliability.

### Time spent:
26 hours