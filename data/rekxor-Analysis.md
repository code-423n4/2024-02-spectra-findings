# Spectra Audit Analysis : Code4rena | 23rd Feb 2024 - 1st Mar 2024

|                           |                                                      |
| :------------------------ | ---------------------------------------------------- |
| **Project Name**          | **Spectra**                                                 |
| **Repository**   			| [Github](https://github.com/code-423n4/2024-02-spectra/tree/main) |
| **Website**      | [Spectra](https://www.spectra.finance/)                       |
| **X(Twitter)**   | [**ùïè**](https://twitter.com/spectra_finance)             |
| **Total SLoC**  | **976** over **7** contracts                               |

---
## Overview of the Spectra Audit

**Spectra** is an EVM-centric protocol for interest rate derivatives, with an easy-to-use flagship app. Spectra introduces a new financial layer to established protocols like _Aave, Compound, or Yearn_ by creating Principal Tokens and Yield Tokens. Spectra is a permissionless interest rate derivatives protocol for DeFi. The protocol allows to split the yield generated by an Interest Bearing Token (IBT) from the principal asset. The IBT is deposited in the protocol and the user receives Principal Tokens (PT) and Yield Tokens (YT) in return. The PT represents the principal asset and the YT represents the yield generated by the IBT. Holders of the yield token for a specific IBT can claim the yield generated by the corresponding deposited IBTs during the time they hold the YT.

**The key contracts of Spectra finance for this Audit are**:

These contracts are central to the functionality of the Spectra protocol. Focusing on them first will provide a solid foundation for understanding the protocol's operation and how it manages user assets, and leverages the working of protocol in practical scenarios.

- **PrincipalToken.sol**:
  Principal Token contract is the main contract of this protocol. It satisfies the [`EIP5095`](https://eips.ethereum.org/EIPS/eip-5095) and [`EIP 2612`](https://eips.ethereum.org/EIPS/eip-2612#security-considerations) token standard. It uses ERC-2612 Permit Extension which allows users to modify the allowance mapping using a signed message, instead of through `msg.sender`.

- **YieldToken.sol**:
  Yield Token is the next contract that has logic associated with the PrincipalToken contract. Whenever there is any deposit of Interest Bearing Token by user, withdrawal of shares, burning of shares, the PrincipalToken invokes function calls of this contract to have corresponding effect on generated YieldTokens of the user. 

### System Overview

### Scope

- _**AMBeacon.sol**_: It inherits `IBeacon` proxy from `openzeppelin` contracts. It has been modified to use the `AccessManaged` for access control instead of `Ownable` pattern of OpenZeppelin. The authority can change the implementation the beacon points to using `upgradeTo()`, thus upgrading the proxies that use this beacon. The functions are made `restricted` via the `AccessManager` modifier enabling Role Based Access Control on functions, assigned by the intitial admin.
  
- _**AMTransparentUpgradeableProxy.sol**_: This contract implements a proxy that is upgradeable through an associated {ProxyAdmin} instance. If any account other than the admin calls the proxy, the call will be forwarded to the implementation contract, even if that call matches the function exposed by the proxy itself. In the other scenario, if admin calls the proxy, it can call the `upgradeToAndCall` function but any other call won't be forwarded to the implementation contract. Thus, restricting admin to call only proxy function, and users to call only implementation functions.

- _**AMProxyAdmin.sol**_: This contract is assigned as the admin of `AMTransparentUpgradeableProxy.sol` contract. It inherits the `AccessManaged` contract of OpenZeppelin. It has a single function that is restrircted `upgradeAndCall()` which upgrades proxy to implementation and calls a function on the new implementation.
  
- _**PrincipalToken.sol**:_
  Principal Token contract is the main contract of this protocol. It satisfies the [`EIP5095`](https://eips.ethereum.org/EIPS/eip-5095) and [`EIP 2612`](https://eips.ethereum.org/EIPS/eip-2612#security-considerations) token standard. It uses ERC-2612 Permit Extension which allows users to modify the allowance mapping using a signed message, instead of through `msg.sender`.

- _**YieldToken.sol**:_
  Yield Token is the next contract that has logic associated with the PrincipalToken contract. Whenever there is any deposit of Interest Bearing Token by user, withdrawal of shares, burning of shares, the PrincipalToken invokes function calls of this contract to have corresponding effect on generated YieldTokens of the user.
  
- _**PrincipalTokenUtil.sol**_: This is a library that implements the business logic of Principal Token contract. It extensively defines the function that are responsible to compute yield, yieldFee, TokenizationFee, and FlashLoanFee. Performing conversions between assets to share and vice versa.

- _**RayMath.sol**_: To allow all ERC20 tokens with varying `decimals` for eg: USDC with 6 decimals, the protocol introduces `RayMath` library, which has 1 unit equivalent to 27 decimals. It does conversions from and to `Ray` unit to scale up decimal to avoid precision loss, while calculating values such as yield.

### Privileged Roles
Some functions are secured with an OpenZeppelin Access Manager contract, enabling centralized role management distributed to DAO accounts. The following roles are defined with the OpenZeppelin AccessManager:

- ADMIN_ROLE - `roleId` 0 - the Access Manager super admin. Can grant and revoke any role. Set by default in the Access Manager constructor.
- UPGRADER_ROLE - `roleId` 1 - the users who can upgrade the protocol implementations.
- PAUSER_ROLE - `roleId` 2 - the DAO address that can pause the protocol (in case of emergency).
- FEE_SETTER_ROLE - `roleId` 3 - the role that can change the fees in the protocol.
- REGISTRY_ROLE - `roleId` 4 - the users who can call the registry contract to register new contracts addresses.
- REWARDS_HARVESTER_ROLE - `roleId` 5 - the DAO address that can harvest the additional rewards generated by the IBT holdings of the protocol (redistributed to users).
- REWARDS_PROXY_SETTER_ROLE - `roleId` 6 - the DAO address that can setup a rewards proxy to be able to claim IBT rewards.

### Approach Taken-in Evaluating The Spectra Protocol

Accordingly, I analyzed and audited the subject in the following steps:

1. **Getting Familiar with the documentation**:
    I opened the docs and starting going through the basic definitions and Defi Concepts used in the protocol. After getting an essence about PrincipalTokens and YieldTokens. I wanted to know the practical usecases of Spectra finance that could attract users in this bull market.
 
2. **Protocol Core Contract Overview**:

    I focused on thoroughly understanding the codebase and providing recommendations to improve its functionality.
    The main goal was to take a close look at the important contracts and how they work together in the Spectra Protocol.

    **Main Contracts I Looked At**

                PrincipalToken.sol
                YieldToken.sol
                PrincipalTokenUtil.sol
                RayMath.sol

    I started my analysis by examining the PrincipalToken.sol contract. Being the core contract, it is also the longest contract for this audit. Everything was coded in the order recommended by solidity, the main logic of depositing assets, withdrawing assets, claiming rewards, updating yield and the getter and setter functions.
   
3. **Comments and Documentation**: While the codebase contains comments, some functions points to their `interface` for natspec. Having the natspec copied in the contract itself makes the job of developer, auditor much easier, avoiding the need to jump to interface contract each time to get the description of the function. Regardless, everything including modifiers, state variables, events, function has an exceptional description stated in the codebase. 

4. **Decimals Handling**: The developers did a great job by introducing a common `decimal` called _Ray_ which is 27 decimals unit. Before making any computations for tokens (assuming the both tokens IBT, PT are of varying decimals), the contracts converts values toRay and fromRay and later does the necessary math.

**Formal Verification**: Consider a professional formal verification of the contract to identify and mitigate any security risks.

### Codebase Quality

Overall, I consider the quality of the Spectra codebase to be excellent. The code appears to be very mature and well-developed. We have noticed the implementation of various standards adhere to appropriately. Details are explained below:

| Codebase Quality Categories              | Comments                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| ---------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Code Maintainability and Reliability** | The codebase demonstrates exceptional maintainability with well-structured functions and comments, promoting readability. It exhibits reliability through defensive programming practices, parameter validation, use of nonReentrant modifier for functions that poses a risk of being reentered, and handling external calls safely. The use of internal functions for related operations enhances code modularity, reducing duplication. Libraries improve reliability by minimizing arithmetic errors. Adherence to standard conventions and practices contributes to overall code quality. Contracts doesn't make use of any magic numbers, such values are embedded in the contract bytecode by declaring them as constants.                                                                       |
| **Code Comments**                        |  The contracts have comments that are used to explain the purpose and functionality of different parts of the contracts, making it easier for developers to understand and maintain the code. The comments provide descriptions of methods, variables, and the overall structure of the contract. For-Exmaple: The code comments in between the functions of PrincipalToken, PrincipalTokenUtil contracts provide essential additional information, showcasing how edge cases of PT/IBT rate are handled. The imported interfaces and contracts are declared, and the contract's title and purpose are described.                                                                                                                                                                         |
| **Documentation**                        |The documentation of the Spectra project is quite comprehensive and detailed, providing a solid overview of how Spectra is structured and how its various functions are intended to work. They have a separate documentation for `devs` which is of extensive use for auditors to get the understand of the protocol, the defi concepts necessary to understand the codebase and the detailed overview of the contract functions and intended behavior. For better understanding of the protocol, the team has perfectly delivered diagrams and architecture flowchart of protocol. The main invariants of the protocol also has been stated by the team. |
| **Testing**                              | The protocol uses foundry to write teset cases. The audit scope of the contracts of size 976 sLOC has been tested against 15k sLOC test suite. Which is exceptional coverage.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| **Code Structure and Formatting**        | The codebase contracts are well-structured and formatted. It inherits from multiple components, adhering for-example OpenZeppelin `Access` standards in some contracts. The constructors initializes the contract with parameters and inherited components. Override functions for each component are provided with accompanying comments explaining their purpose. The code is organized, making it readable and maintainable.                                                                                                                                                                                                                                                   |
### Centralization Risks

The analysis provided highlights several significant systemic and centralization risks present in the Spectra protocol. Some functions are secured with an OpenZeppelin Access Manager contract, enabling centralized role management distributed to DAO accounts.

1. Some IBTs are elligible for additional rewards, and the DAO can claim these rewards and redistribute them to the users. The DAO will be able for such IBTs to setup a reward proxy on top of the PT contract to be able to claim the rewards. The DAO is the only entity that can perform these operations. Not even the user can claim these rewards that they have been rewarded with directly.

2. The protocol acknowledges that a malicious user with a `REWARDS_HARVESTER_ROLE` could claim the rewards and keep them for himself. However, the DAO(trusted) is the only entity that can claim the rewards.

3. The protocol acknowledges that a malicious user with a `REWARDS_PROXY_SETTER_ROLE` could set the rewards proxy to a malicious contract and drain the protocol via the delegatecall. However, the DAO(trusted) is the only entity that can set the rewards prox..

4. The protocol acknowledges that a malicious user with a `FEE_SETTER_ROLE` could set the fees to 100% and drain the protocol. However, the DAO(trusted) is the only entity that can set the fees.

**Properly managing these risks and implementing best practices in security and decentralization will contribute to the sustainability and long-term success of the Spectra protocol.**

### Conclusion

In general, the Spectra project exhibits an interesting and well-developed architecture we believe the team has done an exceptional job regarding the codebase, documentation, but the identified issues need to be addressed to ensure best practices and making Spectra protocol as decentralized it can be, and measures should be implemented to protect the protocol from potential malicious use cases. It is also highly recommended that the team continues to invest in security measures such as mitigation reviews, audits, and bug bounty programs to maintain the security and reliability of the project.

### Time spent:
21 hours

### Time spent:
21 hours