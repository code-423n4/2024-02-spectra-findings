
# QA Report : Spectra Contest | 23rd Feb 2024 - 1st Mar 2024

## Executive summary
**Spectra** is a permissionless interest rate derivatives protocol for DeFi. The protocol allows to split the yield generated by an **Interest Bearing Token** **(IBT)** from the principal asset. The IBT is deposited in the protocol and the user receives **Principal Tokens (PT) and Yield Tokens (YT)** in return. The PT represents the principal asset and the YT represents the yield generated by the IBT. Holders of the yield token for a specific IBT can claim the yield generated by the corresponding deposited IBTs during the time they hold the YT.

## Overview

|                           |                                                      |
| ------------------------ | ---------------------------------------------------- |
| **Project Name**          | **Spectra**                                                 |
| **Repository**   			| [Github](https://github.com/code-423n4/2024-02-spectra/tree/main) |
| **Website**      | [Spectra](https://www.spectra.finance/)                       |
| **X(Twitter)**   | [**𝕏**](https://twitter.com/spectra_finance)             |
| **Total SLoC**  | **976** over **7** contracts                               |

---

## List of Findings
| ID              | Title                                                                                                | Severity       |
| --------------- | ---------------------------------------------------------------------------------------------------- | -------------- |
| [L - 01](#l-01-nonreentrant-modifier-should-be-placed-before-all-other-modifiers) | `nonReentrant` modifier should be placed before all other modifiers                              | _Low_          |
| [L - 02](#l-02-storeratesatexpiry-performs-redundant-check-on-ratesatexpirystored-state-variable) |`storeRatesAtExpiry()` performs redundant check on `ratesAtExpiryStored` state variable                           | _Low_          |
| [L - 03](#l-03-emitting-events-after-external-call-violates-cei-pattern) |Emitting `events` after external call violates CEI pattern                | _Low_          |
| [NC-01](#nc-01-natspec-param-of-_withdrawshares-has-a-typing-mistake) | Natspec @param of `_withdrawShares()` has a typing mistake                  | _Non Critical_ |

---
---

## [L-01] `nonReentrant` modifier should be placed before all other modifiers

#### Description: 

To mitigate the risk of reentrancy attacks, one common approach is to use the `nonReentrant` modifier. This modifier acts as a lock, ensuring that a function cannot be called recursively while it is still in execution. 
However, when using the `nonReentrant` modifier, it is crucial to place it before all other modifiers in a function. Placing it first ensures that all other modifiers are unable to bypass the reentrancy protection.

#### Code Snippets: 

[PrincipalToken.sol::`_depositIBT`](https://github.com/code-423n4/2024-02-spectra/blob/main/src/tokens/PrincipalToken.sol#L750-L769)

[PrincipalToken.sol::`_beforeWithdraw`](https://github.com/code-423n4/2024-02-spectra/blob/main/src/tokens/PrincipalToken.sol#L828-L842)

#### Recommendation: 
By following the best practice of placing the `nonReentrant` modifier before all other modifiers, you can significantly reduce the risk of reentrancy-related issues which can arised by the modifier placed before. Though in our case `whenNotPaused` and `notExpired` modifier doesn't have such behavior. But following best practices ensures safety of our protocol in best way possible.

```solidity
function _depositIBT(
        uint256 _ibts,
        address _ptReceiver,
        address _ytReceiver
    ) internal nonReentrant notExpired whenNotPaused returns (uint256 shares)  
```

```solidity
 function _beforeWithdraw(uint256 _assets, address _owner) internal nonReentrant whenNotPaused  {
	  //code
  }
```
##
## [L-02] `storeRatesAtExpiry()` performs redundant check on `ratesAtExpiryStored` state variable

#### Description: 
Whenever we make a function call to storeRatesAtExpiry(), we check beforehand if the value of the variable is false. If it is false, then only we make a call to this function. Having an extra check in the function itself appears to be redundant check, that doesn't make any difference when interacting with the core logic of the contract(s).

```solidity
 function storeRatesAtExpiry() public override afterExpiry {
        if (ratesAtExpiryStored) {   //performing check once again inside the function
            revert RatesAtExpiryAlreadyStored();
        }
        ratesAtExpiryStored = true;
        // PT rate not rounded up here
        (ptRate, ibtRate) = _getCurrentPTandIBTRates(false);
        emit RatesStoredAtExpiry(ibtRate, ptRate);
    }
```

#### Code Snippets: 

1.[_beforeRedeem()](https://github.com/code-423n4/2024-02-spectra/blob/main/src/tokens/PrincipalToken.sol#L805-L821)
```solidity
if (block.timestamp >= expiry) {
      if (!ratesAtExpiryStored) {   //check
          storeRatesAtExpiry();
      }
 }
```
2. [_beforeWithdraw()](https://github.com/code-423n4/2024-02-spectra/blob/main/src/tokens/PrincipalToken.sol#L828-L842) 

```solidity
if (block.timestamp >= expiry) {
      if (!ratesAtExpiryStored) {    //check
          storeRatesAtExpiry();
      }
 }
```
3. [_updatePTandIBTRates()](https://github.com/code-423n4/2024-02-spectra/blob/main/src/tokens/PrincipalToken.sol#L879-L894) 

```solidity
if (block.timestamp >= expiry) {
      if (!ratesAtExpiryStored) {   //check
          storeRatesAtExpiry();
      }
 }
```

#### Recommendation: 
Either we can remove the check that we are making before calling this function (better), or removing the if statement from the function itself, that checks for the value of the `bool` variable and reverts if the value of variable is true.


##
## [L-03] Emitting `events` after external call violates CEI pattern

#### Description: 
CEI stands for Check Effects Interaction, which is a pattern followed by developers to avoid reentrancy attacks. It states that, the order of solidity statements being executed should follow CEI, implementing checks first, then making necessary updates on state variables and emitting data to off-chain components, and lastly interacting via external calls. 

#### Code locations:

[PrincipalToken.sol::redeem()](https://github.com/code-423n4/2024-02-spectra/blob/main/src/tokens/PrincipalToken.sol#L229-L237)

[PrincipalToken.sol::redeemForIBT()](https://github.com/code-423n4/2024-02-spectra/blob/main/src/tokens/PrincipalToken.sol#L253-L262)

[PrincipalToken.sol::updateYield()](https://github.com/code-423n4/2024-02-spectra/blob/main/src/tokens/PrincipalToken.sol#L340-L366)

[PrincipalToken.sol::_withdrawShares()](https://github.com/code-423n4/2024-02-spectra/blob/main/src/tokens/PrincipalToken.sol#L780-L798)

```solidity
  function _withdrawShares(
        uint256 _ibts,
        address _receiver,
        address _owner,
        uint256 _ptRate,
        uint256 _ibtRate
    ) internal returns (uint256 shares) {
        if (_ptRate == 0) {
            revert RateError();
        }
        // convert ibts to shares using provided rates
        shares = _ibts.mulDiv(_ibtRate, _ptRate, Math.Rounding.Ceil);
        // burn owner's shares (YT and PT)
        if (block.timestamp < expiry) {
            IYieldToken(yt).burnWithoutUpdate(_owner, shares);
        }
        _burn(_owner, shares);     //violates CEI
        emit Redeem(_owner, _receiver, shares);
    }
```

#### Recommendation: 
We should emit events as part of the "E" in "CEI", aka, prior to external transfers and calls. 

```solidity
  function _withdrawShares(
        uint256 _ibts,
        address _receiver,
        address _owner,
        uint256 _ptRate,
        uint256 _ibtRate
    ) internal returns (uint256 shares) {
        if (_ptRate == 0) {
            revert RateError();
        }
        // convert ibts to shares using provided rates
        shares = _ibts.mulDiv(_ibtRate, _ptRate, Math.Rounding.Ceil);
        // burn owner's shares (YT and PT)
        if (block.timestamp < expiry) {
            IYieldToken(yt).burnWithoutUpdate(_owner, shares);
        }
        emit Redeem(_owner, _receiver, shares);          //emitting before making external call
        _burn(_owner, shares);
        
    }
```
***
---

## [NC-01] Natspec @param of `_withdrawShares()` has a typing mistake
#### Description :
At [line](https://github.com/code-423n4/2024-02-spectra/blob/main/src/tokens/PrincipalToken.sol#L774) , the _address_ has been mistyped as addresss. It isn't any issue, but since this is a QA report. We aim at having zero possible errors in our code as well as comments. 

```solidity
774    * @param _receiver The address of the receiver of the assets
```

##
 